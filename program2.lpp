%{
#include"lex.h"
using namespace std;
int coln = 1;
int errn = 0;
%}

%option outfile="program2_lex.cpp"
%option noyywrap
%option yylineno

CHEAT       [\x00-\xFF]{-}[(*/)]
MULTILINE   "/*"{CHEAT}["*/"]?
SLCOMMENT   (\/\/.*[\n])
KEYWORD     "int"|"void"|"class"|"new"|"print"|"read"|"return"|"while"|"if"|"else"|"this" 
NUMBER      [0-9]+
RELOP       "=="|"!="|"<="|">="|">"|"<"
SUMOP       "+"|"-"|"||"
PRODOP      "*"|"/"|"%"|"&&"
UNAOP       "+"|"-"|"!"
OPRS        [\[\]\{\}\;\,\(\)\=\.]|"//"|{RELOP}|{SUMOP}|{PRODOP}|{UNAOP} 
ERRTERM     [\[\]{}<>!\+\-\*\/%;,()=. \t\n]
ID          [\_A-Za-z][\_A-Za-z0-9]* 
NOTERRTERM  [^ \n\t\[\]\{\}!&|=<>\+\-\*\/\%\;\,\(\)]

%x COMMENT INNERERROR WORDERROR

%%

"/*" {
  updateAtts(yylineno, coln, yyleng, "COMMENT", yytext);
  BEGIN(COMMENT);
  return COMM; }

<COMMENT>[^*\n]* {
  updateAtts(yylineno, coln, yyleng, "COMMENT", yytext);
  coln += yyleng;
  return COMM; }

<COMMENT>"*"+[^*/\n]* {
  updateAtts(yylineno, coln, yyleng, "COMMENT", yytext);
  coln += yyleng; 
  return COMM; } 

<COMMENT>\n {
  updateAtts(yylineno, coln, yyleng, "COMMENT", yytext);
  coln = 1;
  return COMM; }

<COMMENT>"*"+"/" {
  updateAtts(yylineno, coln, yyleng, "COMMENT", yytext);
  coln += yyleng;
  BEGIN(INITIAL); 
  return COMM; }

{SLCOMMENT} {
  updateAtts(yylineno, coln, yyleng, "COMMENT", yytext);
  coln = 1; 
  return COMM; }

{KEYWORD} {
  updateAtts(yylineno, coln, yyleng, yytext, "");
  coln+= yyleng;
  return KEYW; }

{RELOP} {
  updateAtts(yylineno, coln, yyleng, "R-OP", yytext);
  coln += yyleng; 
  return ROP; }

{SUMOP} {
  updateAtts(yylineno, coln, yyleng, "S-OP", yytext);
  coln += yyleng; 
  return SOP; }

{PRODOP} {
  updateAtts(yylineno, coln, yyleng, "P-OP", yytext);
  coln += yyleng; 
  return POP; }

{UNAOP} {
  updateAtts(yylineno, coln, yyleng, "U-OP", yytext);
  coln += yyleng; 
  return UOP; } 

{OPRS} { 
  updateAtts(yylineno, coln, yyleng, yytext, "");
  coln += yyleng;
  return OPS; }

{ID} {
  updateAtts(yylineno, coln, yyleng, "ID", yytext);
  coln+= yyleng;
  return IDEN; }

{NUMBER} {
  updateAtts(yylineno, coln, yyleng, "NUMBER", yytext);
  coln+= yyleng;
  return NUM; }

[ ] {
  updateAtts(yylineno, coln, yyleng, "SPACE", "");
  coln+= yyleng;
  return WSPC; }

[\n] {
  updateAtts(yylineno, coln, yyleng, "NEWLINE", "");
  coln = 1;
  return WSPC; }

[\t] {
  updateAtts(yylineno, coln, yyleng, "WSPACE", "");
  coln+= yyleng;
  return WSPC; }

.{ERRTERM} {
  updateAtts(yylineno, coln, yyleng, "CHRERR", yytext);
  coln+=yyleng;
  return CHRERR; }


. {
  updateAtts(yylineno, coln, yyleng, "ERROR", yytext);
  coln += yyleng;
  errn++;
  yyless(0);
  BEGIN(WORDERROR);
  if(errn > 20) {
    return MAXERR;
  }
}

<WORDERROR>.{NOTERRTERM}* {
  yymore();
  BEGIN(INNERERROR);
} 

<INNERERROR>"&&"|"||" {
  yyless(yyleng-2);
  updateAtts(yylineno, coln, yyleng, "&&/||ERROR", yytext);
  BEGIN(INITIAL);
  return WRDERR;
}

<INNERERROR>{ERRTERM} {
  yyless(yyleng-1);
  updateAtts(yylineno, coln, yyleng, "WSERROR", yytext);
  BEGIN(INITIAL);
  return WRDERR;
}

<INNERERROR>. {
  yymore();
  BEGIN(WORDERROR);
}
%%
